"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.traverse = traverse;

var _debug = _interopRequireDefault(require("debug"));

var _nodes = require("./nodes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug.default)("webassemblyjs:ast:traverse");

function removeNodeInBody(node, fromNode) {
  switch (fromNode.type) {
    case "ModuleMetadata":
      fromNode.sections = fromNode.sections.filter(function (n) {
        return n !== node;
      });
      break;

    case "Module":
      fromNode.fields = fromNode.fields.filter(function (n) {
        return n !== node;
      });
      break;

    case "Program":
    case "Func":
      // $FlowIgnore it says References?
      fromNode.body = fromNode.body.filter(function (n) {
        return n !== node;
      });
      break;

    default:
      throw new Error("Unsupported operation: removing node of type: " + String(fromNode.type));
  }
}

function _findParent(parentPath, cb) {
  if (parentPath == null) {
    throw new Error("node is root");
  }

  var currentPath = parentPath;

  while (cb(currentPath) !== false) {
    // Hit the root node, stop
    // $FlowIgnore
    if (currentPath.parentPath == null) {
      break;
    } // $FlowIgnore


    currentPath = currentPath.parentPath;
  }
}

function createPath(node, parentPath) {
  function remove() {
    if (parentPath == null) {
      throw new Error("Can not remove root node");
    }

    var parentNode = parentPath.node;
    removeNodeInBody(node, parentNode);
    node._deleted = true;
    debug("delete path %s", node.type);
  } // TODO(sven): do it the good way, changing the node from the parent


  function replaceWith(newNode) {
    // Remove all the keys first
    // $FlowIgnore
    Object.keys(node).forEach(function (k) {
      return delete node[k];
    }); // $FlowIgnore

    Object.assign(node, newNode);
  }

  return {
    node: node,
    parentPath: parentPath,
    // $FlowIgnore: References?
    findParent: function findParent(cb) {
      return _findParent(parentPath, cb);
    },
    replaceWith: replaceWith,
    remove: remove
  };
} // recursively walks the AST starting at the given node. The callback is invoked for
// and object that has a 'type' property.


function walk(node, callback, parentPath) {
  if (node._deleted === true) {
    return;
  }

  var path = createPath(node, parentPath); // $FlowIgnore

  callback(node.type, path);
  Object.keys(node).forEach(function (prop) {
    var value = node[prop];

    if (value === null || value === undefined) {
      return;
    }

    var valueAsArray = Array.isArray(value) ? value : [value];
    valueAsArray.forEach(function (v) {
      if (typeof v.type === "string") {
        walk(v, callback, path);
      }
    });
  });
}

var noop = function noop() {};

function traverse(n, visitors) {
  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;
  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
  var parentPath = null;
  Object.keys(visitors).forEach(function (visitor) {
    if (!_nodes.nodeAndUnionTypes.includes(visitor)) {
      throw new Error("Unexpected visitor ".concat(visitor));
    }
  });
  walk(n, function (type, path) {
    if (typeof visitors[type] === "function") {
      before(type, path);
      visitors[type](path);
      after(type, path);
    }

    var unionTypes = _nodes.unionTypesMap[type];

    if (!unionTypes) {
      throw new Error("Unexpected node type ".concat(type));
    }

    unionTypes.forEach(function (unionType) {
      if (typeof visitors[unionType] === "function") {
        before(unionType, path);
        visitors[unionType](path);
        after(unionType, path);
      }
    });
  }, parentPath);
}